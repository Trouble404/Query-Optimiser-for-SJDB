# Query-Optimiser-for-SJDB
Database Programming Exercise


## 可优化的思路


* （1）子句局部优化。
如等价谓词重写，WHERE和HAVING条件化简中的大部分情况。

* （2）子句间关联优化。
子句与子句之间关联的语义存在优化的可能，如外连接消除、连接消除、子查询优化、视图重写等。

* （3）局部与整体的优化。
协同局部与整体。如OR重写并集规则需要考虑UNION操作（UNION是变换后的整体形式）的花费和OR操作（OR是局部表达式）的花费。

* （4）形式变化优化
多个子句存在嵌套，可能通过形式的变化完成优化。如：嵌套连接消除。

* （5）语义优化
根据完整性约束，SQL表达的含义等信息对语句进行语义优化

* （6）其他优化
根据一些规则对非SPJ做的其他优化，根据硬件环境进行的并行查询优化。

* 它们都是依据关系代数和启发式规则进行。

## 关系模型

### 关系数据结构

* 即二维结构，二维表。即数据库中的表。
* 关系是一种对象
* 关系即是表
* 关系的元数据，即表结构，通常称为列或属性。
* 关系的数据，即表的行数据，通常称为元组（`tuple`），也称为记录(`record`)。 

### 关系操作集合

* 并，交，差，积，选择，投影，连接，除。。
* 选择：单个关系中筛选元组。
* 投影：单个关系中筛选列。
* 连接：多个关系中根据列间的逻辑运算筛选元组（自然连接，等值连接）
* 除：多个关系中根据条件筛选元组（NOT EXISTS 的子查询实现除）
* 并：多个关系合并元组（用UNION实现并）
* 交：多个关系中根据条件筛选元组（用两次NOT IN 实现交）
* 差：多个关系中根据条件筛选元组（NOT IN 子查询实现差）
* 积：无连接条件。N*M条元组


### 关系类型

```Java
R <op> S
```

* 自然连接：R和S中“公共属性”，结果包括公共属性名字上相等的所有元组的组合，在结果中把重复的列去掉。（是同时从列和行的角度进行去重）

* @-连接：R和S中没有公共属性，结果包括在R和S中满足操作符@的所有组合。@通常包括：```< <=, =, =, >=```。即从关系R和S的广义笛卡儿积中选取A，B属性相等的那些元组，是从“行”的角度进行运算。

* 等值连接：操作符是 = 的@-连接。

* 半连接：结果包括在S中公共属性名字上相等的元组的所有的R中的元组。即结果包括R的部分元组，而R中的部分元组的公共属性的值在S中同样存在。SQL中没有自己的连接操作符，使用EXISTS， IN 关键字做子句的子查询常被查询优化器转换为半连接。

* 反连接：结果是在S中没有在公共属性名字上相等的元组的R的元组。即为半连接的补集，反连接有时称为反半连接。在SQL中没有自己的连接操作符，使用了 NOT EXISTS 则被查询优化器转换为反半连接。

* 外连接（左外连接）：结果包括R中的所有元组。若在S中有在公共属性名字上相等的元组，则正常连接；若在S中没有公共属性名字上相等的元组，则依旧保留此元组，并将对应的其他列设为NULL

* 外连接（右外连接）：结果包括S中的所有元组。若在R中有在公共属性名字上相等的元组，则正常连接；若在R中没有公共属性名字上相等的元组，则依旧保留此元组，并将对应的其他列设为NULL

* 外连接（全外连接）：结果包括S和R中的所有元组。对于每个元组，若在另一个关系中有在公共属性名字上相等的元组，则正常连接；若在另一人关系中没有公共属性名字上相等的元组，则依旧保留此元组，并将对应的其他列设为NULL


## 查询句与二叉树

* 叶子是关系（表）

* 内部结点是运算符（或称算子，操作符，如 LEFT OUT JOIN，表示左右子树的运算方式）

* 子树是子表达式或SQL片段

* 根结点是最后运算符的操作符

* 根结点运算后，得到的是SQL查询优化后的结果

* 这样一棵树就是一个查询的路径

* 多个关系连接，连接顺序不同，可以得出多个类似的二叉树

* 查询优化就是找出代价最小的二叉树，即最优的查询路径。

* 基于代价估算的查询优化就是通过计算和比较，找出花费最少的是优二叉树。


## 从运算符的角度考虑优化

不同的运算符优化可c减少中间生成物的大小和数量，节约IO和内存CPU等，从而提高执行速度。前提是优化前和优化后是等价的。

### 选择 —— 基本选择性质

* 对同一个表的同样选择条件，作一次即可。

* 可优化的原因：
    * 幂等性：多次应用同一个选择有同样的效果
    * 交换性：应用选择的次序在最终结果中没有影响
    * 选择可有效减少在它的操作数中的元组数的运算（元组数减少）

### 选择 —— 分解有复杂条件的选择

* 合取：合并多个选择为更少的需求值的选择，多个等式可以合并。它等价于针对这些单独的一系列选择。

* 析取：分解它们使得其成员选择可被移动或单独优化。它等价于选择的并集。

### 选择 —— 和叉积

*尽可能选做选择：关系有N和M行，先做积运算将包含N*M行。先做选择运算，减少N和M，则可避免不满足条件的条件参与积的运算，节约时间减少结果的大小。

* 尽可能下推选择：如果积不跟随着选择运算，可尝试使用其他规则从表达式树更高层下推选择。

### 选择 —— 和集合运算

* 选择下推到的集合运算中：选择在差集，交集和并集算子上满足分配律。

### 选择 —— 和投影

* 在投影之前进行选择：如果选择条件中引用的字段是投影中的字段的子集，则选择与投影满足交换性。

### 投影 —— 和基本投影性质

* 尽可能先做投影：投影是幂等性的；投影可以减少元组大小。

### 投影 —— 和集合运算。

* 投影下推到集合运算中：投影在差集，交集和并集运算上满足分配律。

## 运算规则主导的优化

### 连接、笛卡儿积 交换律

* 做连接、做积运算，可交换前后位置，其结果不变。如两表连接算法中嵌套连接算法，对外表和内表有要求，外表尽可能小则有利于做“基于块的嵌套循环连接“，所以，通过交换律可以把元组少的表作为外表。

### 连接、笛卡儿积 结合律

* 做连接、做积运算，如果新的结合有利于减少中间关系的大小，则可优先处理。

### 投影的串接定律

* 在同一个关系上，只需要做一次投影运算，且一次投影时选择多列同时完成。所以许多数据库优化引擎为同一个关系收集齐本关系上的所有列（目标列和 WHERE， GROUP BY 等子句的本关系的列）

### 选择的串接定律

* 选择条件可以合并，使得可一次就检查全部条件，不必多次过滤元组，所以可以把同层的合取条件收集在一起，统一判断。

### 选择与投影的交换律

*（1）先投影后选择，可以改为先选择后投影，这对于以行为存储格式的主流数据库而言，很有优化意义。存储方式总是在先获得元组后才能解析得到其中的列。

*（2）先择选后投影，可以改为带有选择条件中列的投影后再选择，最后完成最外层的投影，这样，使得内层的选择和投影可以同时进行。

### 选择与笛卡儿积的分配律

* 条件下推到相关的关系上，先做选择后做积运算，这样可以减小中间结果的大小。

### 选择与并的分配律

* 条件下推到相关的关系上，先做选择后做并运算，可以减小每个关系输出结果的大小。

### 选择与差的分配律

* 条件下推到相关的关系上，先做选择后做差运算，可以减小每个关系输出结果的大小。

### 投影与笛卡儿积的分配律

* 先做投影后做积，可减少做积前每个元组的长度，使得再做积后得到新元组的长度变短。

### 投影与并的分配律

* 先做投影后做并，可减少做并前每个元组的长度。













